#include "main.h"

using namespace std;

/*
 * Start of execution.
 */
int main(int num_args, char ** args) {

	// Check whether an argument has been passed (1 default argument
	// is always passed; working directory).
	if (num_args == 1) {
		cerr << "No file path was given as an argument. Program Exiting..." << endl;
		return 1;
	}
	else {
		ifstream ifile(args[1]);

		// Check whether a file exists at the first given argument.
		if (!ifile) {
			cerr << "No file exists at the specified path. Program Exiting..." << endl;
			return 1;
		}

		unordered_set<char> delims = { ' ', '-' };
		auto word_cond = [](const string& s) -> const bool {
			return s.size() >= MIN_WORD_LENGTH;
		};

		// Retrieve words from input file.
		vector<string> words = getWords(ifile, delims);

		// Count the number of occurrences of each unique word.
		unordered_set<char> punc = { '.', ',', '?', '\'', '"', '!', '(', ')', ':' };
		unordered_map<string, int> count = countUniqueWords(words, word_cond, punc);

		// Output the total occurrences of each unique word in a results file.
		ofstream ofile("results.txt");
		ofile << "Total number of occurences of each word - in descending order.\n";
		ofile << "Word\tUsage\n" << flip_map(count);

		return 0;
	}
}

/*
 * Adds the data contained in the specified multimap \p mp, to the
 * specified output stream \p os.
 *
 * Each key-value entry in the multimap is added to the output stream
 * in the format "KEY\tVALUE\n". Key-value entries are added in reverse
 * order.
 *
 * @param os		The output stream to add to.
 * @param wordCount	The word counter to add to the output stream.
 *
 * @returns			The output stream, with the data from the output stream
 *					added.
 */
ostream &operator<<(ostream &os, const multimap<int, string>& wordCount) {
	multimap<int, string> mmp;
	
	// Iterates over each key-value entry in the specified map /p mp.
	for (auto i = wordCount.rbegin(); i != wordCount.rend(); ++i) {
		os << i->second << "\t" << i->first << "\n";
	}
	return os;
}

/*
 * Generates a multimap whose pairs are created from flipping
 * the key-value entries of the specified map \p mp.
 *
 * @param mp	The map whose key-value entires to flip.
 *
 * @returns		The multimap resulting from flipping the
                key-value entries of the specified map.
 */
template<typename A, typename B>
multimap<B, A> flip_map(const unordered_map<A, B>& toFlip) {
	multimap<B, A> flipped;

	// Iterates over each key-value entry in the specified
	// map \p mp.
	for (auto i = toFlip.begin(); i != toFlip.end(); ++i) {
		flipped.insert(pair<B, A>(i->second, i->first));
	}

	return flipped;
}

/*
 * Count the number of occurrences of each unique word (case-insensitive and
 * punctuation-insensitive) in the specified vector of words \p words.
 * Punctuation is considered to include ".,?'"!():" only.
 *
 * @param words		The vector of words to count the number of
 *					occurrences of each unique word from.
 * @param cond		The condition to be passed in order for a
 *					word to be counted. 
 *					A function which is supplied a string as an
 *					a boolean specifying whether the supplied
 *					string is to be counted.
 * @param ignore	The characters to ignore when considering whether
 *					words are unique.
 *
 * @returns			A map containing unique words as keys and their
 *					total number of occurrences as the associated
 *					values.
 */
unordered_map<string, int> countUniqueWords(const vector<string>& words, const bool cond(const string&), 
	const unordered_set<char>& ignore) {
	unordered_map<string, int> wordCount;

	// Iterates over each value in the specified vector \p words.
	for (const auto& cWord : words) {
		string word = toLower(cWord);
		word = removeChars(word, ignore);
		
		// Check whether the current word was found in a previous iteration.
		// If true - add one to the count associated with the word.
		if (wordCount.count(word) > 0) {
			wordCount[word] += 1;
		}
		else {

			// Check whether the current word passes the specified condition
			// \p cond.
			// If true - initialise a new key-value entry, with the key as
			// the current word and the value as 1.
			if (cond(word)) {
				wordCount[word] = 1;
			}
		}
	}

	return wordCount;
}

/*
 * Retrieve all words from the specified input stream \p in. Words are
 * generated by dividing the input stream by new line and by the specified
 * set of delimiters \p delimiters.
 *
 * @param in			The input stream.
 *
 * @param delimiters	The delimiters used to split the input stream into
 *						words. Defaults to an empty set, in which case, each
 *                      line in the input stream will be considered a word.
 *
 * @returns				The vector containing all words from the input stream.
 */
vector<string> getWords(istream& in, const unordered_set<char>& delimiters) {
	vector<string> words;
	string str;

	// Iterate through each line in the specified input stream \p in.
	while (getline(in, str)) {
		
		// Check whether there are any delimiters.
		// If true, split the current line by the delimiters,
		// storing the result in the words vector.
		if (!delimiters.empty()) {
			words = split(str, delimiters, words);
		}
		else {
			words.push_back(str);
		}
	}

	return words;
}

/*
 * Converts the specified string \p str to lowercase.
 *
 * @param str	The string to convert to lowercase.
 */
string toLower(const string& str) {
	string newStr;

	// Iterate over each character in the specified
	// string.
	for (const auto& c : str) {
		newStr += tolower(c);
	}

	return newStr;
}

/*
 * Removes the characters specified in the set \p toRemove from the specified
 * string \p str.
 *
 * @param str		The string to remove the specified characters from.
 * @param toRemove	The set containing the characters to remove from the string.
 *
 * @return			A new string with the specified characters removed.
 */
string removeChars(const string& str, const unordered_set<char>& toRemove) {
	string newStr;

	// Iterate over each character in the specified string.
	for (const auto& c : str) {
		
		// Check whether to remove the current character.
		if (toRemove.count(c) == 0) {
			newStr += c;
		}
	}

	return newStr;
}

/*
 * Splits the specified string \p str by the specified set of delimiters
 * \p delimiters. Stores each section of the divided string in the specified
 * vector \p words.
 *
 * @param str			The string to split by the delimiters in \p delimiters.
 * @param delimiters	The delimiters to use in splitting the string \p str.
 * @param words			The vector in which to store the resulting sections of
 *					    the split string.
 *
 * @return				The specified vector with the split sections added.
 */
vector<string> split(const string& str, const unordered_set<char>& delimiters,
	vector<string>& words) {
	// c_str stores the currently built string section, since the last
	// delimiter was found.
	string cStr;

	// Iterate through all characters in the specified string \p str.
	for (const auto& c : str) {

		// Check whether the current character was found within
		// the set of specified delimiters \p delimiters.
		if (delimiters.count(c) > 0) {

			// Check whether the currently built string section is
			// not empty. If true, add the string section to \p words.
			if (cStr.length() != 0) {
				words.push_back(cStr);
				cStr = "";
			}
		}
		else {
			cStr += c;
		}
	}

	// Check whether the final string section is not empty.
	// If true, add the final string section to \p words.
	if (cStr.length() != 0) {
		words.push_back(cStr);
	}

	return words;
}
