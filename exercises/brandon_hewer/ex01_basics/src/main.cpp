#include "main.h"

using namespace std;

/*
 * Start of execution.
 */
int main(int num_args, char ** args) {

	// Check whether an argument has been passed (1 default argument
	// is always passed; working directory).
	if (num_args == 1) {
		cerr << "No file path was given as an argument. Program Exiting..." << endl;
		return 0;
	}
	else {
		ifstream ifile(args[1]);

		// Check whether a file exists at the first given argument.
		if (!ifile) {
			cerr << "No file exists at the specified path. Program Exiting..." << endl;
			return 0;
		}

		unordered_set<char> delims = { '.', ',', '?', '!', '(', ')', ':', '\'', 
			'"', ' ', ';', '\t'};
		auto word_cond = [](const string s) -> const bool {
			return s.size() >= MIN_WORD_LENGTH;
		};

		// Retrieve words from input file.
		vector<string> words = getWords(ifile, delims);
		ifile.close();

		// Count the number of occurrences of each unique word.
		unordered_map<string, int> count = countUniqueWords(words, word_cond);

		// Output the total occurrences of each unique word in a results file.
		ofstream ofile("results.txt");
		ofile << "Word\tUsage\n" << flip_map(count);
		ofile.close();

		return 1;
	}
}

/*
 * Adds the data contained in the specified multimap \p mp, to the
 * specified output stream \p os.
 *
 * Each key-value entry in the multimap is added to the output stream
 * in the format "KEY\tVALUE\n". Key-value entries are added in reverse
 * order.
 *
 * \param os	The output stream to add to.
 * \param mp	The multimap whose data to add to the output stream.
 *
 * \returns		The output stream, with the data from the output stream
 *              added.
 */
ostream &operator<<(ostream &os, const multimap<int, string>& mp) {
	multimap<int, string> mmp;
	
	// Iterates over each key-value entry in the specified map /p mp.
	for (auto i = mp.rbegin(); i != mp.rend(); ++i) {
		os << i->second << "\t" << i->first << "\n";
	}
	return os;
}

/*
 * Generates a multimap whose pairs are created from flipping
 * the key-value entries of the specified map \p mp.
 *
 * \param mp	The map whose key-value entires to flip.
 *
 * \returns		The multimap resulting from flipping the
                key-value entries of the specified map.
 */
template<typename A, typename B>
multimap<B, A> flip_map(const unordered_map<A, B>& mp) {
	multimap<B, A> mmp;

	// Iterates over each key-value entry in the specified
	// map \p mp.
	for (auto i = mp.begin(); i != mp.end(); ++i) {
		mmp.insert(pair<B, A>(i->second, i->first));
	}
	return mmp;
}

/*
 * Count the number of occurrences of each unique word in the
 * specified vector of words \p words.
 *
 * \param words	The vector of words to count the number of
 *              occurrences of each unique word from.
 * \param cond	The condition to be passed in order for a
 *              word to be counted. 
 *              A function which is supplied a string as an
 *              a boolean specifying whether the supplied
 *              string is to be counted.
 *
 * \returns		A map containing unique words as keys and their
 *              total number of occurrences as the associated
 *              values.
 */
unordered_map<string, int> countUniqueWords(const vector<string>& words, const bool cond(string)) {
	unordered_map<string, int> count;

	// Iterates over each value in the specified vector \p words.
	for (auto i = words.begin(); i != words.end(); ++i) {
		string word = *i;
		unordered_map<string, int>::iterator m_iter = count.find(*i);

		// Check whether the current word was found in a previous iteration.
		// If true - add one to the count associated with the word.
		if (m_iter != count.end()) {
			count[word] = 1 + m_iter->second;
		}
		else {

			// Check whether the current word passes the specified condition
			// \p cond.
			// If true - initialise a new key-value entry, with the key as
			// the current word and the value as 1.
			if (cond(word)) {
				count[word] = 1;
			}
		}
	}

	return count;
}

/*
 * Retrieve all words from the specified input stream \p in. Words are
 * generated by dividing the input stream by new line and by the specified
 * set of delimiters \p delimiters.
 *
 * \param in			The input stream.
 *
 * \param delimiters	The delimiters used to split the input stream into
 *						words. Defaults to an empty set, in which case, each
 *                      line in the input stream will be considered a word.
 *
 * \returns				The vector containing all words from the input stream.
 */
vector<string> getWords(istream& in, const unordered_set<char>& delimiters = {}) {
	vector<string> words;
	string str;

	// Iterate through each line in the specified input stream \p in.
	while (getline(in, str)) {
		
		// Check whether there are any delimiters.
		// If true, split the current line by the delimiters,
		// storing the result in the words vector.
		if (!delimiters.empty()) {
			split(str, delimiters, words);
		}
		else {
			words.push_back(str);
		}
	}
	return words;
}

/*
 * Splits the specified string \p str by the specified set of delimiters
 * \p delimiters. Stores each section of the divided string in the specified
 * vector \p words.
 *
 * \param str			The string to split by the delimiters in \p delimiters.
 *
 * \param delimiters	The delimiters to use in splitting the string \p str.
 *
 * \param words			The vector in which to store the resulting sections of
 *					    the split string.
 */
vector<string> split(const string str, const unordered_set<char>& delimiters, 
	vector<string>& words = vector<string>()) {
	// c_str stores the currently built string section, since the last
	// delimiter was found.
	string c_str;

	// Iterate through all characters in the specified string \p str.
	for (auto i = str.begin(); i != str.end(); ++i) {
		// Attempt to find the current character in the specified set
		// of delimiters \p delimiters.
		unordered_set<char>::iterator s_iter = delimiters.find(*i);

		// Check whether the current character was found within
		// the set of specified delimiters \p delimiters.
		if (s_iter != delimiters.end()) {

			// Check whether the currently built string section is
			// not empty. If true, add the string section to \p words.
			if (c_str.length() != 0) {
				words.push_back(c_str);
				c_str = "";
			}
		}
		else {
			c_str += *i;
		}
	}

	// Check whether the final string section is not empty.
	// If true, add the final string section to \p words.
	if (c_str.length() != 0) {
		words.push_back(c_str);
	}

	return words;
}